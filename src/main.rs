use anyhow::Result;
use core::str;

use esp_idf_svc::{eventloop::EspSystemEventLoop, hal::prelude::Peripherals};

mod board;
mod keypad;
mod kodi;
mod led;
mod wifi;

#[toml_cfg::toml_config]
struct Config {
    #[default("guest")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("http://10.1.2.3:8080/jsonrpc")]
    kodi_endpoint: &'static str,
    #[default("Basic dGVzdDpwYXNz")]
    kodi_auth_basic: &'static str,
}

fn loop_once(
    board: &mut board::Board,
    last: &mut Option<char>,
    debounce: &mut i8,
    toggle_led: &mut bool,
) -> Result<()> {
    let mut key = keypad::scan_keypad(&mut board.keypad)?;
    // work around bad keyboard
    if key == Some('#') && *last == Some('3') {
        key = Some('3');
    }
    if key != *last {
        if *debounce >= 0 {
            log::info!("{last:?} bounced to {key:?}?");
        }
        *last = key;
        *debounce = 3i8;
    } else if *debounce > 0 {
        *debounce -= 1;
    } else if *debounce == 0 {
        *debounce = -1;
        log::info!("Key pressed {key:?}");
        match key {
            Some('1') => {
                log::info!("toggling play/pause");
                kodi::play_pause()?;
            }
            Some('2') => {
                if *toggle_led {
                    log::info!("Turning LED on");
                    led::neopixel(led::Rgb::new(10, 10, 0), &mut board.led)?;
                    *toggle_led = false;
                } else {
                    log::info!("Turning LED off");
                    led::neopixel(led::Rgb::new(0, 0, 0), &mut board.led)?;
                    *toggle_led = true;
                }
            }
            Some('3') => {
                log::info!("ADC value: {}", board.adc.read(&mut board.adc_pin)?);
            }
            Some('A') => {
                log::info!("Playing next");
                kodi::next()?;
            }
            Some('*') => {
                log::info!("Decrementing volume");
                kodi::update_vol(-2i8)?;
                // repeat key after 200ms
                *debounce = 20i8;
            }
            Some('0') => {
                log::info!("Incrementing volume");
                kodi::update_vol(2i8)?;
                *debounce = 20i8;
            }
            _ => (),
        };
    }
    Ok(())
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;

    // `CONFIG` constant is auto-generated by toml_config
    let kodi_config = CONFIG;

    let _wifi = wifi::wifi(
        kodi_config.wifi_ssid,
        kodi_config.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    let mut board = board::init(peripherals.pins, peripherals.rmt, peripherals.adc1)?;
    let mut last: Option<char> = None;
    let mut debounce = 1i8;

    let mut errors = 0i8;

    let mut toggle_led = false;

    // signal we got wifi and we're ready
    led::blink(&mut board.led, 10, 10, 0, 300)?;

    loop {
        if let Err(e) = loop_once(&mut board, &mut last, &mut debounce, &mut toggle_led) {
            log::warn!("Got error: {:?}", e);
            errors += 1;
            if errors > 10 {
                log::warn!("Too many errors, rebooting");
                led::blink(&mut board.led, 10, 0, 0, 300)?;
                esp_idf_svc::hal::reset::restart();
            }
        }
        std::thread::sleep(std::time::Duration::from_millis(10));
    }
}
